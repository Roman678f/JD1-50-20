/*
 * Сергей Шпаковский
 *
 * Это программное обеспечение является публичной и открытой
 * информацией.
 *
 * АВТОР НЕ ДАЁТ НИКАКИХ ГАРАНТИЙ, ЯВНЫХ ИЛИ КОСВЕННЫХ (ВКЛЮЧАЯ - НО
 * НЕ ОГРАНИЧИВАЯСЬ ИМИ - ГАРАНТИИ РЕАЛИЗУЕМОСТИ), СООТВЕТСТВИЯ
 * ОПРЕДЕЛЁННОМУ НАЗНАЧЕНИЮ ИЛИ НЕНАРУШЕНИЯ УСЛОВИЙ, ЧТО СОДЕРЖИМОЕ
 * ДАННОГО ФАЙЛА ПОДХОДИТ ДЛЯ КАКИХ-ЛИБО ЦЕЛЕЙ ИЛИ ЧТО ЛЮБОЕ
 * ИСПОЛЬЗОВАНИЕ ИЛИ РЕАЛИЗАЦИЯ ТАКОГО СОДЕРЖИМОГО НЕ БУДЕТ НАРУШАТЬ
 * КАКИХ-ЛИБО ПАТЕНТОВ ТРЕТЬЕЙ СТОРОНЫ, АВТОРСКИХ ПРАВ, КОММЕРЧЕСКОЙ
 * ТАЙНЫ ИЛИ ИНЫХ ПРАВ.
 */
package operators;

/**
 * Класс, показывающий приоритетность операторов на примерах.
 *
 * @version   1.00 29.08.2020
 * @author    Сергей Шпаковский
 */
public class OperatorsPriorityMain {
    
    /**
     * Точка входа и работа с операторами.
     *
     * @param args - передаваемые строкой параметры с консоли
     */
    public static void main(String[] args){
        int two = 2;
        int eight = 8;
        int result = 0;
        boolean resultBoolean = false;
        
        /*
         * Результат выражения 5. Потому что 2 / 8 = 0.
         */
        result = 5 + 2 / 8;
        System.out.println(result);
    
        /*
         * Результат выражения 0. Потому что 7 / 8 = 0.
         */
        result = (5 + 2) / 8;
        System.out.println(result);
        
        /*
         * В литералах - ошибка компиляции с 2++.
         * В переменных результат выражения 0. Потому что 7 / 8 = 0
         * и two++ выполняется после вычисления выражения справа
         * от знака равно.
         */
        result = (5 + two++) / 8;
        System.out.println(result);
        
        /*
         * В литералах - ошибка компиляции с 2++ и --8.
         * В переменных результат выражения 1. Потому что 7 / 7 = 0
         * и two++ выполняется после вычисления выражения справа
         * от знака равно.
         */
        two = 2;
        result = (5 + two++) / --eight;
        System.out.println(result);
        
        /*
         * В литералах - ошибка компиляции с 2++ и --8.
         * В переменных результат выражения 0.
         * Потому что (5 * 2 / 4) / 8 = 0 и two++ выполняется
         * после вычисления выражения справа от знака равно.
         */
        two = 2;
        eight = 8;
        result = (5 * 2 >> two++) / --eight;
        System.out.println(result);
    
        /*
         * В литералах - ошибка компиляции с 2++ и --8.
         * В переменных результат выражения 1.
         * Потому что (5 + 7) < 20 и (22 * 2 / 4) / 7 = 1
         * и two++ выполняется после вычисления выражения справа от
         * знака равно.
         */
        two = 2;
        eight = 8;
        result = (5 + 7 > 20 ? 68 : 22 * 2 >> two++) / --eight;
        System.out.println(result);
        
        /*
         * Выражение (5 + 7 > 20 ? 68 >= 68 : 22 * 2 >> 2++) / --8
         * не компилируется в текущем виде даже после замены 2 и 8
         * переменными с такими же значениями. Не компилируется
         * из-за разных типов возвращаемых тернарным оператором:
         * boolean если true и int если false.
         * В измененном виде результат 1.
         */
        two = 2;
        eight = 8;
        result = (5 + 7 > 20 ? 68 /*>= 68*/ : 22 * 2 >> two++) / --eight;
        System.out.println(result);
    
        /*
         * Результат false, потому что 4 > 3, но 144 > 119.
         */
        resultBoolean = 6 - 2 > 3 && 12 * 12 <= 119;
        System.out.println(resultBoolean);
        
        /*
         * Результат false.
         * Потому что оператор && выдает true
         * только когда обе части true.
         */
        resultBoolean = true && false;
        System.out.println(resultBoolean);
    }
}
